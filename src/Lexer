options{
  STATIC = false;
  JDK_VERSION = "1.5";
}
PARSER_BEGIN(Lexer)
    import java.util.List;
    import java.util.ArrayList;
    import java.io.FileNotFoundException;
	public class Lexer{
		 public static void main(java.lang.String[] args) throws ParseException,TokenMgrError {
			Lexer lexer;
			System.out.println("Lexical analyser is now trying to read file..");
			if(args.length == 1){
			    System.out.println("Lexer is trying to read file: "+args[0]+"...");
			    try{
                    lexer = new Lexer(new java.io.FileInputStream(args[0]));
                    System.out.println("Starting to parse..");
                    for(Token token : tokenize(lexer)){
                        String name = LexerConstants.tokenImage[token.kind];
                        //String name = token.image;
                        System.out.println(token.beginLine +  ":" + name + "=>"+token.image);
                    }
                    System.out.println("Input was read.");
			    }catch(java.io.FileNotFoundException e){
                    System.out.println("Lexer: the file"+args[0]+"was not found..");
			        return;
			    }
			}
		}
		public static List<Token> tokenize (Lexer lexer) throws FileNotFoundException{
		    List<Token> tokens = new ArrayList<Token>();
		    Token token = lexer.getNextToken();
		    while(token.kind != LexerConstants.EOF){
		        tokens.add(token);
		        token = lexer.getNextToken();
		    }
		    return tokens;
		}
}PARSER_END(Lexer)
SKIP:{
  " "
  | "\t"
  | "\n"
  | "\r"
  |< "//" (~["\r", "\n"])* >
  |<"/*" (~["*"])* "*" (~["*","/"] (~["*"])* "*" | "*")* "/">
}

TOKEN:{

   <CONST: (["c"]["o"]["n"]["s"]["t"])>
  | <TRUE: (["t"]["r"]["u"]["e"])>
  | <FALSE: (["f"]["a"]["l"]["s"]["e"])>
  | <CONSTR:  (["c"]["o"]["n"]["s"]["t"]["r"]["u"]["c"]["t"])>
  | <THIS:  (["t"]["h"]["i"]["s"])>
  | <FUNC: (["f"]["u"]["n"]["c"]["t"]["i"]["o"]["n"])>
  | <RETURN: (["r"]["e"]["t"]["u"]["r"]["n"])>
  | <READ: (["r"]["e"]["a"]["d"])>
  | <WRITE: (["w"]["r"]["i"]["t"]["e"])>
  | <CLASS: (["c"]["l"]["a"]["s"]["s"])>
  | <PUBLIC: (["p"]["u"]["b"]["l"]["i"]["c"])>
  | <PRIVATE: (["p"]["r"]["i"]["v"]["a"]["t"]["e"])>
  | <IF: (["i"]["f"])>
  | <THEN: (["t"]["h"]["e"]["n"])>
  | <ELSE: (["e"]["l"]["s"]["e"])>
  | <WHILE: (["a"]["s"]["L"]["o"]["n"]["g"]["A"]["s"])>
  | <INT:(["0"-"9"])+>
  | <ID: (["a"-"z","A"-"Z","0"-"9","_"])+ >
  | <VARID:("$")(["a"-"z","A"-"Z","0"-"9","_"])+ >
  | <COMMA:([","])>
  | <ADD:(["+"])>
  | <ADDASSIGN: (["+"]["="])>
  | <SUBASSIGN: (["-"]["="])>
  | <MULASSIGN: (["*"])(["="])>
  | <POWASSIGN: (["*"]["*"]["="])>
  | <DIVASSIGN: (["/"])(["="])>
  | <INC:(["+"]["+"])>
  | <SUB:(["-"])>
  | <DEC:(["-"]["-"])>
  | <MUL:(["*"])>
  | <POW:(["*"]["*"])>
  | <DIV:(["/"])>
  | <MOD:(["%"])>
  | <LCB:(["("])>
  | <RCB:([")"])>
  | <LBR:(["{"])>
  | <RBR:(["}"])>
  | <EQ:(["="])>
  | <NOT:(["!"])>
  | <NEQ:(["!"]["="])>
  | <GT:([">"])>
  | <LT:(["<"])>
  | <GOE:([">"]["="])>
  | <LOE:(["<"]["="])>
  | <ARROW:(["-"][">"])>
  | <COMPARISON:(["="]["="])>
  | <AND:(["&"]["&"])>
  | <OR:(["|"]["|"])>
  | <SC:([";"])>
  | <STRLIT: "\"" (~["\"", "\\"] | "\\\"" | "\\\\")* "\"" >
}

TOKEN_MGR_DECLS :
{
  int stringSize;
}

SimpleNode program() #program:{}
{
    classDeclaration()
}
void classDeclaration()#classDeclaration:{}
{
    <CLASS>id()<LBR>declarationList()<RBR>
}
void id()#ID:{Token t;}{
    t = <ID> {jjThis.value = t.image;}
}
void declarationList()#declarationlist:{}
{
    (declaration() (<COMMA> declaration())*)
}
void declaration()#declaration:{}
{
    varDeclaration() | funDeclaration() | constructor()
}
void varDeclaration():{}
{
    ((accessMod())? (constant())? (varDeclarationList()|(varAssignList())<SC>) )
}
void accessMod()#accessMod:{}
{
    <PRIVATE> | <PUBLIC>
}
void constant()#constant:{}
{
    <CONST>
}
void varDeclarationList()#varDecList:{}
{
    varID()|((<COMMA>)varID())*
}
void varID()#varID:{}
{
    <VARID>
}
void varAssignList()#varAssignList:{}
{
   (<VARID> <EQ> value())|((<COMMA>varID())*<EQ>value())
}
void value()#value:{}
{
    bool()|integer()|string()
}
void bool()#bool:{}
{
    <TRUE>|<FALSE>
}
void integer()#integer:{}
{
    <INT>
}
void string()#string:{}
{
    <STRLIT>
}
void funDeclaration():{}
{
    ((accessMod())? <FUNC><ID><LCB>params()<RCB>statement())
}
void constructor():{}
{
    ((accessMod())?<CONSTR><ID><LCB>(params())?<RCB>constrStmt())
}
void constrStmt()#constrStmt:{}
{
    <THIS><ARROW><ID><EQ><ID><SC>
}
void params()#parameters:{}
{
    (varID() | ((<COMMA>varID())*))?
}
void statement()#statement:{}
{
    expressionStmt() | returnStmt() | iterationStmt() | compoundStmt() | ifStmt()
}
void expressionStmt()#expression:{}
{
    expression()<SC>
}
void returnStmt()#returnStmt:{}
{
    <RETURN>(expression())?<SC>
}
void iterationStmt()#iteration:{}
{
    <WHILE><LCB>expression()<RCB>statement()
}
void compoundStmt():{}
{
    <LBR>(statement())*<RBR>
}
//void ifStmt():{}
//{
//Todo
//}
//void expression():{}
//{
//
//}