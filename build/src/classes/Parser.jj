/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Parser.jj */
/*@egen*/options{
  STATIC = false;
  JDK_VERSION = "1.5";
             
                 
}
PARSER_BEGIN(Parser)
    import java.util.List;
    import java.util.ArrayList;
    import java.io.FileNotFoundException;
	public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();

/*@egen*/
	    public static void main(String[] args)throws ParseException{
	        try{
                Parser parser = new Parser(new java.io.FileInputStream(args[0]));
                //parser.program();
                SimpleNode root = parser.program();
                root.dump("");
	        }catch(Exception e){
	            System.out.println(e.getMessage());
	        }
	    }
		 /*public static void main(java.lang.String[] args) throws ParseException,TokenMgrError {
			Lexer lexer;
			System.out.println("Lexical analyser is now trying to read file..");
			if(args.length == 1){
			    System.out.println("Lexer is trying to read file: "+args[0]+"...");
			    try{
                    lexer = new Lexer(new java.io.FileInputStream(args[0]));
                    System.out.println("Starting to parse..");
                    for(Token token : tokenize(lexer)){
                        String name = LexerConstants.tokenImage[token.kind];
                        //String name = token.image;
                        System.out.println(token.beginLine +  ":" + name + "=>"+token.image);
                    }
                    System.out.println("Input was read.");
			    }catch(java.io.FileNotFoundException e){
                    System.out.println("Lexer: the file"+args[0]+"was not found..");
			        return;
			    }
			}
		}
		public static List<Token> tokenize (Lexer lexer) throws FileNotFoundException{
		    List<Token> tokens = new ArrayList<Token>();
		    Token token = lexer.getNextToken();
		    while(token.kind != LexerConstants.EOF){
		        tokens.add(token);
		        token = lexer.getNextToken();
		    }
		    return tokens;
		}*/
}PARSER_END(Parser)

TOKEN:{

   <CONST: "const">
  | <TRUE: "true">
  | <FALSE: "false">
  | <CONSTR:  "construct">
  | <THIS:  "this">
  | <FUNC: "function">
  | <RETURN: "return">
  | <READ: "read">
  | <WRITE: "write">
  | <CLASS: "class">
  | <IF: "if">
  | <THEN: "then">
  | <ELSE: "else">
  | <WHILE: "asLongAs">
  | <INT:(["0"-"9"])+>
  | <ID: (["a"-"z","A"-"Z","0"-"9","_"])+ >
  | <VARID:("$")(["a"-"z","A"-"Z","0"-"9","_"])+ >
  | <COMMA:([","])>
  | <ADD:(["+"])>
  | <SUB:(["-"])>
  | <MUL:(["*"])>
  | <POW:"**">
  | <DIV:(["/"])>
  | <MOD:(["%"])>
  | <LCB:(["("])>
  | <RCB:([")"])>
  | <LBR:(["{"])>
  | <RBR:(["}"])>
  | <EQ:(["="])>
  | <NOT:(["!"])>
  | <NEQ:"!=">
  | <GT:([">"])>
  | <LT:(["<"])>
  | <GOE:">=">
  | <LOE:"<=">
  | <ARROW:"->">
  | <COMPARISON:"==">
  | <AND:"&&">
  | <OR:"||">
  | <SC:([";"])>
  | <STRLIT: "\"" (~["\"", "\\"] | "\\\"" | "\\\\")* "\"" >
}

SKIP:{
  " "
  | "\t"
  | "\n"
  | "\r"
  |< "//" (~["\r", "\n"])* >
  |<"/*" (~["*"])* "*" (~["*","/"] (~["*"])* "*" | "*")* "/">
}

SimpleNode program()        :{/*@bgen(jjtree) program */
  program jjtn000 = new program(this, JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) program */
     try {
/*@egen*/
     (classDeclaration())*
     <EOF>/*@bgen(jjtree)*/
     {
       jjtree.closeNodeScope(jjtn000, true);
       jjtc000 = false;
     }
/*@egen*/
     {return jjtn000;}/*@bgen(jjtree)*/
     } catch (Throwable jjte000) {
       if (jjtc000) {
         jjtree.clearNodeScope(jjtn000);
         jjtc000 = false;
       } else {
         jjtree.popNode();
       }
       if (jjte000 instanceof RuntimeException) {
         throw (RuntimeException)jjte000;
       }
       if (jjte000 instanceof ParseException) {
         throw (ParseException)jjte000;
       }
       throw (Error)jjte000;
     } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
     }
/*@egen*/
}
void classDeclaration()          :{/*@bgen(jjtree) classDecl */
  classDecl jjtn000 = new classDecl(this, JJTCLASSDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) classDecl */
    try {
/*@egen*/
    <CLASS>id()<LBR>declaration()<RBR>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void id():{/*@bgen(jjtree) id */
           id jjtn000 = new id(this, JJTID);
           boolean jjtc000 = true;
           jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}{/*@bgen(jjtree) id */
    try {
/*@egen*/
    <ID>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void declaration():{/*@bgen(jjtree) declaration */
  declaration jjtn000 = new declaration(this, JJTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) declaration */
    try {
/*@egen*/
    ((varDeclaration()) | (funDeclaration()) | constructor())*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void varDeclaration():{/*@bgen(jjtree) varDeclaration */
  varDeclaration jjtn000 = new varDeclaration(this, JJTVARDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) varDeclaration */
    try {
/*@egen*/
    (constant())* ( varDeclarationList() ) <SC>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void constant():{/*@bgen(jjtree) constant */
  constant jjtn000 = new constant(this, JJTCONSTANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) constant */
    try {
/*@egen*/
    <CONST>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void varDeclarationList():{/*@bgen(jjtree) varDeclarationList */
  varDeclarationList jjtn000 = new varDeclarationList(this, JJTVARDECLARATIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) varDeclarationList */
   try {
/*@egen*/
   <VARID>  (<EQ>)*  (LOOKAHEAD(2)(<INT>|<TRUE>|<FALSE>|<VARID>|<STRLIT>))*/*@bgen(jjtree)*/
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}
void funDeclaration():{/*@bgen(jjtree) funDeclaration */
  funDeclaration jjtn000 = new funDeclaration(this, JJTFUNDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) funDeclaration */
    try {
/*@egen*/
    <FUNC><ID><LCB>params()<RCB>statement()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void constructor():{/*@bgen(jjtree) constructor */
  constructor jjtn000 = new constructor(this, JJTCONSTRUCTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) constructor */
    try {
/*@egen*/
    <CONSTR><LCB>params()<RCB><LBR>(constrStmt())*<RBR>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void constrStmt():{/*@bgen(jjtree) constrStmt */
  constrStmt jjtn000 = new constrStmt(this, JJTCONSTRSTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) constrStmt */
    try {
/*@egen*/
    <THIS><ARROW><VARID><EQ><VARID><SC>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void params():{/*@bgen(jjtree) params */
  params jjtn000 = new params(this, JJTPARAMS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) params */
    try {
/*@egen*/
    <VARID> (<COMMA><VARID>)*/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void statement():{/*@bgen(jjtree) statement */
  statement jjtn000 = new statement(this, JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) statement */
  try {
/*@egen*/
  <LBR>( LOOKAHEAD(2) (expressionStmt() | returnStmt() | iterationStmt() | ifStmt()))*<RBR>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void expressionStmt():{/*@bgen(jjtree) expressionStmt */
  expressionStmt jjtn000 = new expressionStmt(this, JJTEXPRESSIONSTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) expressionStmt */
    try {
/*@egen*/
    expression()<SC>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void returnStmt():{/*@bgen(jjtree) returnStmt */
  returnStmt jjtn000 = new returnStmt(this, JJTRETURNSTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) returnStmt */
    try {
/*@egen*/
    <RETURN>(<VARID>|<ID>)<SC>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void iterationStmt():{/*@bgen(jjtree) iterationStmt */
  iterationStmt jjtn000 = new iterationStmt(this, JJTITERATIONSTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) iterationStmt */
    try {
/*@egen*/
    <WHILE><LCB>comparison()<RCB><THEN>statement()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ifStmt():{/*@bgen(jjtree) ifStmt */
  ifStmt jjtn000 = new ifStmt(this, JJTIFSTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ifStmt */
    try {
/*@egen*/
    <IF><LCB>comparison()<RCB><THEN>statement()[LOOKAHEAD(1)<ELSE><THEN>statement()]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void comparison():{/*@bgen(jjtree) comparison */
  comparison jjtn000 = new comparison(this, JJTCOMPARISON);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) comparison */
    try {
/*@egen*/
    value() [compoperators() value()]/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void value():{/*@bgen(jjtree) value */
  value jjtn000 = new value(this, JJTVALUE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) value */
    try {
/*@egen*/
    <VARID>|<INT>|<STRLIT>|<TRUE>|<FALSE>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void expression():{/*@bgen(jjtree) expression */
  expression jjtn000 = new expression(this, JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) expression */
      try {
/*@egen*/
      LOOKAHEAD(2)  varDeclarationList()
    | LOOKAHEAD(2)  maths()
    | LOOKAHEAD(3) immutable()
    | LOOKAHEAD(3) io()/*@bgen(jjtree)*/
      } catch (Throwable jjte000) {
        if (jjtc000) {
          jjtree.clearNodeScope(jjtn000);
          jjtc000 = false;
        } else {
          jjtree.popNode();
        }
        if (jjte000 instanceof RuntimeException) {
          throw (RuntimeException)jjte000;
        }
        if (jjte000 instanceof ParseException) {
          throw (ParseException)jjte000;
        }
        throw (Error)jjte000;
      } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
        }
      }
/*@egen*/
}
void mutable():{/*@bgen(jjtree) mutable */
  mutable jjtn000 = new mutable(this, JJTMUTABLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) mutable */
    try {
/*@egen*/
    <VARID> | <LCB>expression()<RCB>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void maths():{/*@bgen(jjtree) maths */
  maths jjtn000 = new maths(this, JJTMATHS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) maths */
    try {
/*@egen*/
    value() mathoperators() value()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void compoperators():{/*@bgen(jjtree) compoperators */
  compoperators jjtn000 = new compoperators(this, JJTCOMPOPERATORS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) compoperators */
      try {
/*@egen*/
      <LOE>
    | <LT>
    | <GT>
    | <GOE>
    | <COMPARISON>
    | <NEQ>
    | <NOT>
    | <OR>
    | <AND>/*@bgen(jjtree)*/
      } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
        }
      }
/*@egen*/
}
void mathoperators():{/*@bgen(jjtree) mathoperators */
  mathoperators jjtn000 = new mathoperators(this, JJTMATHOPERATORS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) mathoperators */
     try {
/*@egen*/
     <ADD>
    |<SUB>
    |<MUL>
    |<DIV>
    |<MOD>
    |<POW>/*@bgen(jjtree)*/
     } finally {
       if (jjtc000) {
         jjtree.closeNodeScope(jjtn000, true);
       }
     }
/*@egen*/
}
void immutable():{/*@bgen(jjtree) immutable */
  immutable jjtn000 = new immutable(this, JJTIMMUTABLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) immutable */
    try {
/*@egen*/
    call() | <VARID>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void io():{/*@bgen(jjtree) io */
  io jjtn000 = new io(this, JJTIO);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) io */
    try {
/*@egen*/
    read() | write()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void read():{/*@bgen(jjtree) read */
  read jjtn000 = new read(this, JJTREAD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) read */
    try {
/*@egen*/
    <READ><LCB><RCB>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void write():{/*@bgen(jjtree) write */
  write jjtn000 = new write(this, JJTWRITE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) write */
    try {
/*@egen*/
    <WRITE><LCB>params()<RCB>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void call():{/*@bgen(jjtree) call */
  call jjtn000 = new call(this, JJTCALL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) call */
    try {
/*@egen*/
    <ID><LCB>arguments()<RCB>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
void arguments():{/*@bgen(jjtree) arguments */
  arguments jjtn000 = new arguments(this, JJTARGUMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) arguments */
    try {
/*@egen*/
    (expression() ((<COMMA>expression())*))/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}